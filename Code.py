# -*- coding: utf-8 -*-
"""Untitled3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IkHYJiiOAF_4rM2lebNcgaLcpFl1bZK-
"""



import numpy as np
import sklearn
import time
from scipy.linalg import khatri_rao
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score

# You are allowed to import any submodules of sklearn that learn linear models e.g. sklearn.svm etc
# You are not allowed to use other libraries such as keras, tensorflow etc
# You are not allowed to use any scipy routine other than khatri_rao

# SUBMIT YOUR CODE AS A SINGLE PYTHON (.PY) FILE INSIDE A ZIP ARCHIVE
# THE NAME OF THE PYTHON FILE MUST BE submit.py

# DO NOT CHANGE THE NAME OF THE METHODS my_fit, my_map, my_decode etc BELOW
# THESE WILL BE INVOKED BY THE EVALUATION SCRIPT. CHANGING THESE NAMES WILL CAUSE EVALUATION FAILURE

# You may define any new functions, variables, classes here
# For example, functions to calculate next coordinate or step length
train_data = np.loadtxt('/content/public_trn.txt')
train_questions = train_data[:, :8]
train_answers = train_data[:, 8:]

test_data = np.loadtxt('/content/public_tst.txt')
test_questions = test_data[:, :8]
test_answers = test_data[:, 8:]

print(train_questions.shape)

print(train_answers.shape)
print(test_questions.shape)
print(test_answers.shape)
################################
# Non Editable Region Starting #
################################
def my_fit( X_train, y_train ):
################################
#  Non Editable Region Ending  #
################################

	# Use this method to train your models using training CRPs
	# X_train has 8 columns containing the challenge bits
	# y_train contains the values for responses

	# THE RETURNED MODEL SHOULD BE ONE VECTOR AND ONE BIAS TERM
	# If you do not wish to use a bias term, set it to 0
    # Map to feature space
    X_feat = my_map(X_train)

    # Initialize and train logistic regression
    clf = LogisticRegression(
        penalty='l2',
        solver='liblinear',
        C=1.0,
        tol=1e-4,
        max_iter=1000
    )
    t0 = time.time()
    clf.fit(X_feat, y_train)
    train_time = time.time() - t0

    # Extract model parameters
    w = clf.coef_.ravel()              # shape (45,)
    b = clf.intercept_[0]             # scalar

    # Optional: report training time
    print(f"[my_fit] Training time: {train_time:.4f} s")
    return w, b


################################
# Non Editable Region Starting #
################################
def my_map( X ):
################################
#  Non Editable Region Ending  #
################################

	# Use this method to create features.
	# It is likely that my_fit will internally call my_map to create features for train points
    # 1) Encode bits {0,1} -> {+1,-1}
    X_mod = 1 - 2 * X                    # shape (n, 8)
    # 2) Compute cumulative products phi_i = prod_{k=1..i}(1-2*c_k)
    phi = np.cumprod(X_mod, axis=1)    # shape (n, 8)
    # 3) Prepend bias term
    phi_ext = np.hstack([np.ones((X.shape[0], 1)), phi])  # shape (n, 9)

    # 4) Build unique order-2 monomials phi_ext[i] * phi_ext[j] for i <= j
    n, D = phi_ext.shape              # D = 9
    features = np.empty((n, D * (D + 1) // 2))
    idx = 0
    for i in range(D):
        for j in range(i, D):
            features[:, idx] = phi_ext[:, i] * phi_ext[:, j]
            idx += 1
    return features # shape (n,45)

train_features = my_map(train_questions)
test_features = my_map(test_questions)

print(train_features.shape)
print(test_features.shape)

w,b =my_fit(train_questions, train_answers[:, 0])
y_train_pred = (np.dot(train_features, w) + b > 0).astype(int)
train_accuracy = accuracy_score(train_answers[:, 0], y_train_pred)

print(f"Train Accuracy for Response: {train_accuracy:.4f}")

y_test_pred = (np.dot(test_features, w) + b > 0).astype(int)
test_accuracy = accuracy_score(test_answers[:, 0], y_test_pred)

print(f"Test Accuracy for Response: {test_accuracy:.4f}")

################################
# Non Editable Region Starting #
################################
def my_decode( w ):
################################
#  Non Editable Region Ending  #
################################
    # w_in: array of shape (65,), last entry is bias b
    W = w[:64]
    b = w[64]

    # Build A (65×256) and c (65)
    A = np.zeros((65,256))
    c = np.zeros(65)

    # Eqn for i=0:  p0 - q0 + r0 - s0 = 2·w0
    A[0, 0]     =  1   # p0
    A[0, 64]    = -1   # q0
    A[0, 128]   =  1   # r0
    A[0, 192]   = -1   # s0
    c[0]        =  2*W[0]

    # Eqns for i=1…63: (p_i - q_i + r_i - s_i) + (p_{i-1}-q_{i-1}-r_{i-1}+s_{i-1}) = 2·w_i
    for i in range(1,64):
        # current block
        A[i,     i]     +=  1      # p_i
        A[i, 64 + i]     += -1      # q_i
        A[i,128 + i]     +=  1      # r_i
        A[i,192 + i]     += -1      # s_i
        # previous block
        A[i,     i-1]   +=  1      # p_{i-1}
        A[i, 64 + i-1]  += -1      # q_{i-1}
        A[i,128 + i-1]  += -1      # r_{i-1}
        A[i,192 + i-1]  +=  1      # s_{i-1}
        c[i]             = 2*W[i]

    # Eqn for bias: (p63 - q63 - r63 + s63) = 2·b
    A[64,    63]     =  1   # p63
    A[64,  64+63]    = -1   # q63
    A[64, 128+63]    = -1   # r63
    A[64, 192+63]    =  1   # s63
    c[64]            =  2*b

    # Solve least squares and clamp to ≥0
    x, *_ = np.linalg.lstsq(A, c, rcond=None)
    x = np.clip(x, 0, None)

    # Split back into p, q, r, s
    p = x[       :64]
    q = x[   64  :128]
    r = x[  128  :192]
    s = x[  192  :256]

    return p, q, r, s